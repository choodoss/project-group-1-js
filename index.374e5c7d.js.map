{"mappings":"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","sources":["src/js/add-to-watched&queue.js"],"sourcesContent":["import { load, save } from './localStorageAPI';\nimport { filmCardMacker } from './film-card';\n\ndocument.addEventListener('DOMContentLoaded', function (e) {\n    const refs = {\n        btnWatched: document.querySelector('.button--watched'),\n        btnQueue: document.querySelector('.button--queue'),\n        addToWatchedBtn: document.querySelector('.add-to-watched'),\n        addToQueueBtn: document.querySelector('.add-to-queue'),\n        pagination: document.querySelector('.page-list'),\n        moviesEl: document.querySelector('.films-list'),\n        btnWrapper: document.querySelector('#buttonWrapper'),\n        watchedQueueBtnList: document.querySelector('.header-nav__list-2'),\n    };\n\n})\n\nconst localStorageKeys = {\n    WATCHED: 'watched',\n    QUEUE: 'queue',\n};\n\nconst state = {\n    currentPage: 1,\n    totalPages: 0,\n    activeFilm: null,\n    query: null,\n    whatchedOrQueue: null,\n};\n\nconst resetCurrentPage = () => {\n    // присвоює поточній сторінці значення 1\n    //функція використовується для скидання сторінки на початкове значення при зміні параметрів\n    state.currentPage = 1;\n};\n\nconst clearPagination = () => {\n    //використовується для видалення попередньої пагінації зі сторінки\n    pagination.innerHTML = '';\n};\n\n// const renderPaginationMarkup = () => {\n//   //функція вставляє HTML-код розмітки пагінації на сторінку.\n//   pagination.insertAdjacentHTML('beforeend', paginationMarkup());\n// }; // для пагінації\n\nconst localPaginate = (array, currentPage) => {\n    //функція реалізує локальну пагінацію масиву\n    if (!array) return; // перевіряє, чи переданий масив існуєякщо ні, то повертає undefined\n    const itemsPerPage = 6; //  кількість елементів на одній сторінці\n    const startIndex = (currentPage - 1) * itemsPerPage; // індекс першого елемента поточної сторінки\n    state.totalPages = Math.ceil(array.length / itemsPerPage); // розраховує загальну кількість сторінок\n    return array.slice(startIndex, startIndex + itemsPerPage); //  повертає новий масив, який складається з елементів від startIndex до startIndex + itemsPerPage у переданому масиві\n};\n\nconst updateLibRender = async data => {\n    // функція відображає список фільмів з масиву data\n    try {\n        let markup = '';\n        const warning = `<p class=\"watched-warning\">No movies have been added yet</p>`;\n        resetCurrentPage(); // оновлює значення currentPage на 1\n        const films = localPaginate(data, state.currentPage);\n        if (data === undefined || data.length === 0) {\n            // Якщо data порожній масив або undefined, функція викликає clearPagination() і виводить повідомлення warning\n            clearPagination();\n            markup = warning;\n        } else {\n            markup = await filmCardMacker(films); // викликає функцію для створення розмітки для кожного фільму  і виводить цю розмітку в markup\n            clearPagination();\n            // renderPaginationMarkup();\n        }\n        moviesEl.innerHTML = '';\n        moviesEl.insertAdjacentHTML('beforeend', markup); //  виводить markup у films-list на сторінці\n    } catch (error) {\n        console.error(error);\n    }\n};\n\nconst onBtnAddToLibrary = evt => {\n    //функція відповідає за додавання або видалення фільму зі списку переглянутих\n    //або списку фільмів для перегляду в майбутньому  з локального сховища браузера\n    const watchedFilmsArray = localStorageKeys.WATCHED || []; // записується значення ключа WATCHED з localStorage або порожній масив\n    const queueFilmsArray = localStorageKeys.QUEUE || []; // записується значення ключа QUEUE з localStorage або порожній масив\n\n    if (evt.target.innerText === 'ADD TO WATCHED') {\n        saveToStorageFilm(\n            watchedFilmsArray,\n            localStorageKeys.WATCHED,\n            'WATCHED',\n            evt\n        );\n    } else if (evt.target.innerText === 'REMOVE FROM WATCHED') {\n        deleteFromStorageFilm(\n            watchedFilmsArray,\n            localStorageKeys.WATCHED,\n            'WATCHED',\n            evt\n        );\n    } else if (evt.target.innerText === 'ADD TO QUEUE') {\n        saveToStorageFilm(queueFilmsArray, localStorageKeys.QUEUE, 'QUEUE', evt);\n    } else if (evt.target.innerText === 'REMOVE FROM QUEUE') {\n        deleteFromStorageFilm(\n            queueFilmsArray,\n            localStorageKeys.QUEUE,\n            'QUEUE',\n            evt\n        );\n    }\n};\n\nrefs.btnWrapper.addEventListener('click', onBtnAddToLibrary);\n\nfunction saveToStorageFilm(array, key, keyValue, evt) {\n    array.push(state.activeFilm); //додає обраний фільм до вказаного масиву\n    save(key, array); // зберігає оновлений масив у локальному сховищі браузера\n    evt.target.innerText = `REMOVE FROM ${keyValue}`; // змінює текст на кнопці для показу додавання фільму до списку\n}\n\nfunction deleteFromStorageFilm(array, key, keyValue, evt) {\n    const filteredFilms = array.filter(film => film.id !== state.activeFilm.id); // видаляє обраний фільм з вказаного масиву,використовуючи метод filter для створення нового масиву\n    save(key, filteredFilms); // зберігає оновлений масив у локальному сховищі браузера\n    evt.target.innerText = `ADD TO ${keyValue}`; // змінює текст на кнопці  для показу видалення фільму зі списку\n}\n\nexport function updateMarkupLibrary(evt) {\n    // функція призначена для оновлення розмітки сторінки бібліотеки фільмів в залежності від дії, яку виконує користувач\n    if (evt.target.innerText === 'ADD TO WATCHED') {\n        deleteFromWatchedMarkup();\n    } else if (evt.target.innerText === 'REMOVE FROM WATCHED') {\n        deleteFromWatchedMarkup();\n    } else if (evt.target.innerText === 'ADD TO QUEUE') {\n        deleteFromQueueMarkup();\n    } else if (evt.target.innerText === 'REMOVE FROM QUEUE') {\n        deleteFromQueueMarkup();\n    }\n}\nasync function deleteFromWatchedMarkup() {\n    // функція відповідає за відображення списку фільмів, які вже були переглянуті користувачем.\n    resetCurrentPage();\n    const watchedFilmsinLocalStorage = load(localStorageKeys.WATCHED) || []; // завантажує збережені в localStorage дані про фільми, що були додані до списку переглянутих.\n    const films = localPaginate(watchedFilmsinLocalStorage, state.currentPage); // створюється підмасив фільмів для поточної сторінки\n    updateLibRender(films);\n    chahgeBtnActiveStatus(refs.btnWatched, refs.btnQueue);\n}\n\nasync function deleteFromQueueMarkup() {\n    // функція відповідає за відображення списку фільмів, яких чекають, щоб їх переглянули.\n    resetCurrentPage();\n    const queueFilmsinLocalStorage = load(localStorageKeys.QUEUE) || []; // отримується масив фільмів, які знаходяться в локальному сховищі під ключем \"QUEUE\"\n    const films = localPaginate(queueFilmsinLocalStorage, state.currentPage); // створюється підмасив фільмів для поточної сторінки\n    updateLibRender(films);\n    chahgeBtnActiveStatus(refs.btnQueue, refs.btnWatched);\n}\n\nfunction chahgeBtnActiveStatus(elFirst, elSecond) {\n    // функція змінює статус активності кнопок в інтерфейсі\n    elFirst.classList.add('active'); // треба додати в sass background-color: #ff6b08; на button\n    elSecond.classList.remove('active');\n}\n\n//кнопки на модальному вікні\n\nwindow.onload = () => {\n    // функція запускається тільки тоді, коли вікно браузера та усі елементи сторінки завантажилися\n    const watchedFilms = localStorageKeys.WATCHED || []; // записується значення ключа WATCHED з localStorage або порожній масив\n    const queueFilms = localStorageKeys.QUEUE || []; // записується значення ключа QUEUE з localStorage або порожній масив\n\n    if (watchedFilms.find(film => film.id === state.activeFilm.id)) {\n        // перевіряє чи в масиві watchedFilms є об'єкт з id,який збігається з id активного фільму\n        refs.addToWatchedBtn.innerText = 'REMOVE FROM WATCHED';\n    } else {\n        refs.addToWatchedBtn.innerText = 'ADD TO WATCHED';\n    }\n    if (queueFilms.find(film => film.id === state.activeFilm.id)) {\n        // перевіряє чи в масиві queueFilms є об'єкт з id,який збігається з id активного фільму\n        refs.addToQueueBtn.innerText = 'REMOVE FROM QUEUE';\n    } else {\n        refs.addToQueueBtn.innerText = 'ADD TO QUEUE';\n    }\n}; //кнопки на модальному вікні\n\nconst onClickWatched = async evt => {\n    //  функція обробляє клік на кнопці зі списком переглянутих або чергових фільмів\n    if (evt.target.nodeName !== 'BUTTON') return; // перевіряє, чи клік був на кнопці\n    if (evt.target.classList.contains('active')) return; // перевіряє, чи кнопка не є вже активною\n    const activeBtn = document.querySelector('.active');\n    let key = evt.target.dataset.value.toUpperCase(); // зберігає ключ, що відповідає списку фільмів, який потрібно показати, в стані додатку\n    state.whatchedOrQueue = key;\n    const data = load(localStorageKeys[key]); // завантажує дані з локального сховища, використовуючи ключ\n    updateLibRender(data); // оновлює відображення списку фільмів на сторінці\n    activeBtn.classList.remove('active'); // додає клас .active до натиснутої кнопки\n    evt.target.classList.add('active'); // видаляє  клас .active до натиснутої кнопки\n};\n\nrefs.watchedQueueBtnList.addEventListener('click', onClickWatched);"],"names":["$8nF0j","parcelRequire","document","addEventListener","e","querySelector","$947b8ce99d08fcba$var$localStorageKeys","WATCHED","QUEUE","$947b8ce99d08fcba$var$state","currentPage","totalPages","activeFilm","query","whatchedOrQueue","$947b8ce99d08fcba$var$resetCurrentPage","$947b8ce99d08fcba$var$clearPagination","pagination","innerHTML","$947b8ce99d08fcba$var$localPaginate","array","startIndex","Math","ceil","length","slice","$947b8ce99d08fcba$var$updateLibRender","async","data","markup","warning","films","undefined","$3nfqI","filmCardMacker","moviesEl","insertAdjacentHTML","error","console","$947b8ce99d08fcba$var$saveToStorageFilm","key","keyValue","evt","push","save","target","innerText","$947b8ce99d08fcba$var$deleteFromStorageFilm","filteredFilms","filter","film","id","refs","btnWrapper","watchedFilmsArray","queueFilmsArray","window","onload","queueFilms","find","addToWatchedBtn","addToQueueBtn","watchedQueueBtnList","nodeName","classList","contains","activeBtn","dataset","value","toUpperCase","load","remove","add"],"version":3,"file":"index.374e5c7d.js.map"}